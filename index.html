<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistem Deteksi V3: Filter Cerdas & Perbaikan Mirror</title>
    <!-- Library AI -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <!-- Library AI BARU untuk Deteksi Wajah -->
    <script type="module" src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js"></script>
    <!-- Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Inter', sans-serif; }
        /* Cerminkan video agar terasa natural bagi pengguna */
        #video { transform: scaleX(-1); object-fit: cover; }
        #canvas { position: absolute; top: 0; left: 0; image-rendering: pixelated; }
        .loader-modal { backdrop-filter: blur(10px); }
        .btn-active { background-color: #14b8a6 !important; color: white !important; }
        /* Styling untuk Tombol Radio Filter */
        input[type="radio"]:checked + label {
            background-color: #f59e0b; /* Amber */
            color: #1f2937; /* Dark Gray */
            font-weight: 600;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="loader" class="loader-modal fixed inset-0 z-50 flex flex-col items-center justify-center bg-gray-900 bg-opacity-80">
        <div class="w-16 h-16 border-4 border-teal-400 border-t-transparent rounded-full animate-spin"></div>
        <p id="loader-text" class="mt-4 text-lg text-center w-3/4">Memuat model AI, mohon tunggu...</p>
    </div>

    <div class="relative w-screen h-screen">
        <video id="video" class="w-full h-full" playsinline autoplay muted></video>
        <canvas id="canvas" class="w-full h-full"></canvas>
    </div>

    <div id="ui-container" class="fixed top-0 left-0 w-full p-4 z-10 bg-gradient-to-b from-black/70 to-transparent">
        <div class="max-w-6xl mx-auto flex flex-col xl:flex-row justify-between items-center gap-4">
            <!-- Kontrol Mode Deteksi -->
            <div class="flex items-center bg-gray-800 rounded-lg p-1 space-x-1">
                <button id="mode-object" class="mode-btn px-3 py-2 text-sm font-medium rounded-md btn-active">Deteksi Objek</button>
                <button id="mode-roi-box" class="mode-btn px-3 py-2 text-sm font-medium rounded-md">Zona Kotak</button>
                <button id="mode-roi-line" class="mode-btn px-3 py-2 text-sm font-medium rounded-md">Zona Garis</button>
            </div>
            
            <!-- Kontrol Filter Visual -->
            <div class="flex items-center bg-gray-800 rounded-lg p-1 space-x-1">
                <input type="radio" name="filter" id="filter-none" value="none" class="hidden" checked>
                <label for="filter-none" class="px-3 py-2 text-sm rounded-md cursor-pointer transition-colors bg-amber-500 text-gray-800 font-semibold">Normal</label>

                <input type="radio" name="filter" id="filter-thermal" value="thermal" class="hidden">
                <label for="filter-thermal" class="px-3 py-2 text-sm rounded-md cursor-pointer transition-colors">Termal</label>

                <input type="radio" name="filter" id="filter-negative" value="negative" class="hidden">
                <label for="filter-negative" class="px-3 py-2 text-sm rounded-md cursor-pointer transition-colors">Negatif</label>

                <input type="radio" name="filter" id="filter-teeth" value="teeth" class="hidden">
                <label for="filter-teeth" class="px-3 py-2 text-sm rounded-md cursor-pointer transition-colors">Gigi Kuning</label>
            </div>

            <!-- Status & Info -->
            <div id="status-box" class="text-center bg-gray-800/80 p-2 rounded-lg min-w-[200px]">
                <p id="status" class="text-base font-semibold text-teal-300">Menunggu kamera...</p>
                <p id="calibration-info" class="text-xs text-gray-400">Kalibrasi: Belum ada. Arahkan ke wajah.</p>
            </div>
        </div>
    </div>
    
    <script type="module">
        // Deklarasi di awal karena script ini adalah module
        const { FaceLandmarker, FilesetResolver } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js");
        
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const loader = document.getElementById('loader');
        const loaderText = document.getElementById('loader-text');
        const statusEl = document.getElementById('status');
        const calibrationInfoEl = document.getElementById('calibration-info');
        const modeButtons = document.querySelectorAll('.mode-btn');
        const filterRadios = document.querySelectorAll('input[name="filter"]');
        
        const DETECTION_INTERVAL_MS = 300;
        const PROCESSING_CANVAS_WIDTH = 160;

        const processingCanvas = document.createElement('canvas');
        const processingCtx = processingCanvas.getContext('2d', { willReadFrequently: true });
        
        let objectModel = null;
        let faceLandmarker = null;
        let lastObjectPredictions = [];
        let lastFaceLandmarks = null;
        let currentMode = 'object';
        let currentFilter = 'none'; // 'none', 'thermal', 'negative', 'teeth'
        let pixelsPerCm = null;
        let roiBox = null, roiLine = null, isDrawing = false, startPoint = {};
        
        const AVG_FACE_WIDTH_CM = 14.0;
        const animalClasses = ['bird', 'cat', 'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe'];
        
        function getCategory(className) { /* ... (fungsi sama) ... */
            if (className === 'person') return { name: 'Person', color: '#14b8a6' };
            if (animalClasses.includes(className)) return { name: 'Animal', color: '#f59e0b' };
            return { name: 'Equipment', color: '#6366f1' };
        }

        async function createFaceLandmarkerModel() {
            loaderText.innerText = "Memuat model deteksi wajah...";
            const filesetResolver = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
            faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                    delegate: "GPU"
                },
                outputFaceBlendshapes: false,
                runningMode: "VIDEO",
                numFaces: 1
            });
        }

        async function setupCamera() { /* ... (fungsi sama) ... */ 
            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480, facingMode: 'user' }, audio: false });
            video.srcObject = stream;
            return new Promise(resolve => { video.onloadedmetadata = () => resolve(video); });
        }
        
        // --- Loop Rendering (Pekerjaan Ringan, 60fps) ---
        function renderLoop() {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            // --- PERBAIKAN MIRROR ---
            // Simpan state canvas, cerminkan, dan geser agar pas
            ctx.save();
            ctx.scale(-1, 1);
            ctx.translate(-canvas.width, 0);

            // Terapkan filter visual berdasarkan pilihan
            switch (currentFilter) {
                case 'thermal':
                case 'negative':
                    const processingHeight = Math.round(PROCESSING_CANVAS_WIDTH * (canvas.height / canvas.width));
                    processingCanvas.width = PROCESSING_CANVAS_WIDTH;
                    processingCanvas.height = processingHeight;
                    processingCtx.drawImage(video, 0, 0, PROCESSING_CANVAS_WIDTH, processingHeight);
                    const imageData = processingCtx.getImageData(0, 0, PROCESSING_CANVAS_WIDTH, processingHeight);

                    if (currentFilter === 'thermal') applyThermalFilter(imageData);
                    if (currentFilter === 'negative') applyNegativeFilter(imageData);
                    
                    processingCtx.putImageData(imageData, 0, 0);
                    ctx.drawImage(processingCanvas, 0, 0, canvas.width, canvas.height);
                    break;
                default:
                    // 'none' atau 'teeth' akan menggambar video normal sebagai dasar
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    break;
            }
            
            if (currentMode === 'object') drawObjectPredictions(lastObjectPredictions);
            if (currentFilter === 'teeth') drawTeethOverlay(lastFaceLandmarks);

            if (roiBox) { ctx.strokeStyle = 'yellow'; ctx.lineWidth = 4; ctx.strokeRect(roiBox.x, roiBox.y, roiBox.w, roiBox.h); }
            if (roiLine) { ctx.strokeStyle = 'yellow'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(roiLine.x1, roiLine.y1); ctx.lineTo(roiLine.x2, roiLine.y2); ctx.stroke(); }
            
            // Kembalikan state canvas ke normal
            ctx.restore();
            requestAnimationFrame(renderLoop);
        }

        // --- Loop Deteksi AI (Pekerjaan Berat, ~3fps) ---
        let lastVideoTime = -1;
        async function runDetection() {
            if (video.readyState < 2) { return; } // Pastikan video siap
            const videoTime = video.currentTime;
            if (videoTime === lastVideoTime) { return; } // Hindari proses frame yang sama
            lastVideoTime = videoTime;

            if (objectModel && currentMode === 'object') {
                statusEl.textContent = 'Mendeteksi Objek...';
                const predictions = await objectModel.detect(video);
                lastObjectPredictions = predictions;

                const personPrediction = predictions.find(p => p.class === 'person');
                if (personPrediction) {
                    pixelsPerCm = personPrediction.bbox[2] / AVG_FACE_WIDTH_CM;
                    calibrationInfoEl.textContent = `Kalibrasi OK! 1cm ≈ ${pixelsPerCm.toFixed(2)}px`;
                }
            } else {
                lastObjectPredictions = [];
            }
            
            if (faceLandmarker && currentFilter === 'teeth') {
                const faceLandmarkerResult = faceLandmarker.detectForVideo(video, Date.now());
                if (faceLandmarkerResult.faceLandmarks.length > 0) {
                    lastFaceLandmarks = faceLandmarkerResult.faceLandmarks[0];
                } else {
                    lastFaceLandmarks = null;
                }
            } else {
                lastFaceLandmarks = null;
            }
        }

        // --- Fungsi Menggambar & Filter ---
        function drawObjectPredictions(predictions) { /* ... (fungsi sama) ... */
             predictions.forEach(p => { const [x, y, width, height] = p.bbox; const category = getCategory(p.class); ctx.strokeStyle = category.color; ctx.lineWidth = 4; ctx.strokeRect(x, y, width, height); ctx.fillStyle = category.color; const text = `${category.name} (${Math.round(p.score * 100)}%)`; ctx.font = '16px Inter, sans-serif'; const textWidth = ctx.measureText(text).width; ctx.fillRect(x, y, textWidth + 10, 25); ctx.fillStyle = '#ffffff'; ctx.fillText(text, x + 5, y + 18); if (pixelsPerCm) { const widthCm = (width / pixelsPerCm).toFixed(1); const heightCm = (height / pixelsPerCm).toFixed(1); const measurementText = `Est: ${widthCm}cm x ${heightCm}cm`; const measurementWidth = ctx.measureText(measurementText).width; ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(x, y + height - 20, measurementWidth + 10, 20); ctx.fillStyle = '#ffffff'; ctx.fillText(measurementText, x + 5, y + height - 5); } });
        }
        
        const MOUTH_LANDMARKS_INDICES = [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291, 409, 270, 269, 267, 0, 37, 39, 40, 185, 61]; // Inner lips
        function drawTeethOverlay(landmarks) {
            if (!landmarks) return;
            ctx.fillStyle = 'rgba(255, 255, 0, 0.4)';
            ctx.beginPath();
            
            // Pindahkan ke titik pertama
            const firstPoint = landmarks[MOUTH_LANDMARKS_INDICES[0]];
            ctx.moveTo(firstPoint.x * canvas.width, firstPoint.y * canvas.height);

            // Gambar garis ke semua titik bibir lainnya
            for (let i = 1; i < MOUTH_LANDMARKS_INDICES.length; i++) {
                const point = landmarks[MOUTH_LANDMARKS_INDICES[i]];
                ctx.lineTo(point.x * canvas.width, point.y * canvas.height);
            }
            ctx.closePath();
            ctx.fill();
        }
        
        function applyNegativeFilter(imageData) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];     // Red
                data[i + 1] = 255 - data[i + 1]; // Green
                data[i + 2] = 255 - data[i + 2]; // Blue
            }
        }
        function applyThermalFilter(imageData) { /* ... (fungsi sama) ... */ const data = imageData.data; for (let i = 0; i < data.length; i += 4) { const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3; const thermalColor = mapBrightnessToThermalColor(brightness); data[i] = thermalColor.r; data[i+1] = thermalColor.g; data[i+2] = thermalColor.b; } }
        function mapBrightnessToThermalColor(brightness) { /* ... (fungsi sama) ... */ const t = brightness / 255; let r=0, g=0, b=0; if (t < 0.25) { r = 0; g = t * 4 * 255; b = 255; } else if (t < 0.5) { r = (t - 0.25) * 4 * 255; g = 255; b = 255 - r; } else if (t < 0.75) { r = 255; g = 255 - (t - 0.5) * 4 * 255; b = 0; } else { r = 255; g = (t - 0.75) * 4 * 255; b = g; } return { r, g, b }; }

        // --- Event Listeners & Inisialisasi ---
        filterRadios.forEach(radio => radio.addEventListener('change', (e) => { currentFilter = e.target.value; }));
        // ... (event listener lain tidak berubah)
        function switchMode(newMode) { currentMode = newMode; modeButtons.forEach(btn => { btn.classList.remove('btn-active'); if (btn.id === `mode-${newMode.replace('_', '-')}`) btn.classList.add('btn-active'); }); roiBox = null; roiLine = null; if (currentMode !== 'object') statusEl.textContent = 'Klik & seret untuk menggambar zona'; }
        modeButtons.forEach(btn => btn.addEventListener('click', () => switchMode(btn.id.replace('mode-', '').replace('-', '_'))));
        function handleMouseDown(e) { if (currentMode === 'object') return; isDrawing = true; startPoint = { x: canvas.width - e.offsetX, y: e.offsetY }; }
        function handleMouseMove(e) { if (!isDrawing) return; const endPoint = { x: canvas.width - e.offsetX, y: e.offsetY }; if (currentMode === 'roi-box') { roiBox = { x: Math.min(startPoint.x, endPoint.x), y: Math.min(startPoint.y, endPoint.y), w: Math.abs(startPoint.x - endPoint.x), h: Math.abs(startPoint.y - endPoint.y) }; } else if (currentMode === 'roi-line') { roiLine = { x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y }; } }
        function handleMouseUp() { if (!isDrawing) return; isDrawing = false; if (roiBox) statusEl.textContent = 'Zona Kotak Ditetapkan'; if (roiLine) { statusEl.textContent = 'Zona Garis Ditetapkan'; if (pixelsPerCm) { const dx = roiLine.x2 - roiLine.x1; const dy = roiLine.y2 - roiLine.y1; const distPixels = Math.sqrt(dx*dx + dy*dy); const distCm = (distPixels / pixelsPerCm).toFixed(1); statusEl.textContent = `Zona Garis: Estimasi ${distCm} cm`; } } }
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        
        async function main() {
            loaderText.innerText = 'Memuat model deteksi objek...';
            await Promise.all([
                cocoSsd.load().then(m => objectModel = m),
                createFaceLandmarkerModel()
            ]);
            
            loaderText.innerText = 'Menyalakan kamera...';
            await setupCamera();
            loader.style.display = 'none';

            requestAnimationFrame(renderLoop);
            setInterval(runDetection, DETECTION_INTERVAL_MS);
        }
        main();
    </script>
</body>
</html>

