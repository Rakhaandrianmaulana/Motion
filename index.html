<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistem Deteksi Cerdas v4 (Pemuatan Cepat)</title>
    <!-- Library AI -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js"></script>
    <!-- Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Inter', sans-serif; }
        #video { transform: scaleX(-1); object-fit: cover; }
        #canvas { position: absolute; top: 0; left: 0; image-rendering: pixelated; }
        .loader-modal { backdrop-filter: blur(10px); transition: opacity 0.5s ease-out; }
        
        /* Efek "Keren" */
        .btn-active { 
            background-color: #14b8a6 !important; 
            color: white !important; 
            box-shadow: 0 0 15px rgba(20, 184, 166, 0.7);
        }
        input[type="radio"]:checked + label {
            background-color: #f59e0b;
            color: #1f2937;
            font-weight: 600;
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.7);
        }
        .status-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse {
            50% { opacity: .7; }
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- Loader yang Ditingkatkan -->
    <div id="loader" class="loader-modal fixed inset-0 z-50 flex flex-col items-center justify-center bg-gray-900 bg-opacity-80">
        <img src="https://www.gstatic.com/images/branding/googlelogo/svg/googlelogo_light_color_404x140.svg" alt="Google Logo" class="h-12 mb-8 animate-pulse">
        <p id="loader-text" class="mt-4 text-lg text-center w-3/4">Menginisialisasi sistem...</p>
        <div class="w-3/4 max-w-sm bg-gray-700 rounded-full h-2.5 mt-4 overflow-hidden">
            <div id="progress-bar" class="bg-teal-400 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
    </div>

    <div class="relative w-screen h-screen">
        <video id="video" class="w-full h-full" playsinline autoplay muted></video>
        <canvas id="canvas" class="w-full h-full"></canvas>
    </div>

    <!-- UI (tidak berubah signifikan) -->
    <div id="ui-container" class="fixed top-0 left-0 w-full p-4 z-10 bg-gradient-to-b from-black/70 to-transparent">
        <div class="max-w-6xl mx-auto flex flex-col xl:flex-row justify-between items-center gap-4">
             <div class="flex items-center bg-gray-800 rounded-lg p-1 space-x-1">
                <button id="mode-object" class="mode-btn px-3 py-2 text-sm font-medium rounded-md btn-active">Deteksi Objek</button>
                <button id="mode-roi-box" class="mode-btn px-3 py-2 text-sm font-medium rounded-md">Zona Kotak</button>
                <button id="mode-roi-line" class="mode-btn px-3 py-2 text-sm font-medium rounded-md">Zona Garis</button>
            </div>
            <div class="flex items-center bg-gray-800 rounded-lg p-1 space-x-1">
                <input type="radio" name="filter" id="filter-none" value="none" class="hidden" checked>
                <label for="filter-none" class="px-3 py-2 text-sm rounded-md cursor-pointer transition-colors bg-amber-500 text-gray-800 font-semibold">Normal</label>
                <input type="radio" name="filter" id="filter-thermal" value="thermal" class="hidden">
                <label for="filter-thermal" class="px-3 py-2 text-sm rounded-md cursor-pointer transition-colors">Termal</label>
                <input type="radio" name="filter" id="filter-negative" value="negative" class="hidden">
                <label for="filter-negative" class="px-3 py-2 text-sm rounded-md cursor-pointer transition-colors">Negatif</label>
                <input type="radio" name="filter" id="filter-teeth" value="teeth" class="hidden">
                <label for="filter-teeth" class="px-3 py-2 text-sm rounded-md cursor-pointer transition-colors">Gigi Kuning</label>
            </div>
            <div id="status-box" class="text-center bg-gray-800/80 p-2 rounded-lg min-w-[200px]">
                <p id="status" class="text-base font-semibold text-teal-300">Menunggu kamera...</p>
                <p id="calibration-info" class="text-xs text-gray-400">Kalibrasi: Belum ada.</p>
            </div>
        </div>
    </div>
    
    <script type="module">
        const { FaceLandmarker, FilesetResolver } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js");
        
        // ... (Deklarasi semua elemen DOM)
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const loader = document.getElementById('loader');
        const loaderText = document.getElementById('loader-text');
        const progressBar = document.getElementById('progress-bar');
        const statusEl = document.getElementById('status');
        // ... (sisa elemen UI)

        // --- Sistem Cache dengan IndexedDB ---
        const DB_NAME = 'AIModelCacheDB';
        const STORE_NAME = 'models';
        const FACE_MODEL_KEY = 'face_landmarker_v1';
        const FACE_MODEL_URL = 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task';

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onupgradeneeded = () => request.result.createObjectStore(STORE_NAME);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function saveModelToDB(db, key, data) {
            const tx = db.transaction(STORE_NAME, 'readwrite');
            tx.objectStore(STORE_NAME).put(data, key);
            return tx.complete;
        }

        async function loadModelFromDB(db, key) {
            const tx = db.transaction(STORE_NAME, 'readonly');
            const request = tx.objectStore(STORE_NAME).get(key);
            return new Promise(resolve => {
                request.onsuccess = () => resolve(request.result);
            });
        }
        
        async function fetchAndCacheModel(db) {
            const response = await fetch(FACE_MODEL_URL);
            if (!response.ok) throw new Error("Gagal mengunduh model");
            
            const reader = response.body.getReader();
            const totalSize = +response.headers.get('Content-Length');
            let loaded = 0;
            const chunks = [];

            while(true) {
                const { done, value } = await reader.read();
                if (done) break;
                chunks.push(value);
                loaded += value.length;
                progressBar.style.width = `${(loaded / totalSize) * 100}%`;
            }

            const blob = new Blob(chunks);
            const buffer = await blob.arrayBuffer();
            await saveModelToDB(db, FACE_MODEL_KEY, buffer);
            return buffer;
        }

        // --- Variabel State Aplikasi ---
        let objectModel = null, faceLandmarker = null;
        let lastObjectPredictions = [], lastFaceLandmarks = null;
        let currentMode = 'object', currentFilter = 'none';
        // ... (sisa variabel state)

        async function createModels() {
            const db = await openDB();
            
            // 1. Muat Model Deteksi Objek (dari jaringan, karena ringan)
            loaderText.innerText = "Memuat model deteksi objek...";
            progressBar.style.width = '10%';
            const objectModelPromise = cocoSsd.load().then(m => objectModel = m);
            
            // 2. Muat Model Wajah (dari Cache atau Jaringan)
            let faceModelBuffer = await loadModelFromDB(db, FACE_MODEL_KEY);
            if (faceModelBuffer) {
                loaderText.innerText = "Memuat model wajah dari cache...";
                progressBar.style.width = '60%';
            } else {
                loaderText.innerText = "Mengunduh model wajah (hanya sekali)...";
                faceModelBuffer = await fetchAndCacheModel(db);
            }
            
            const filesetResolver = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
            faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                baseOptions: { modelAssetPath: faceModelBuffer, delegate: "GPU" },
                runningMode: "VIDEO", numFaces: 1
            });

            await objectModelPromise; // Tunggu model objek selesai jika belum
            progressBar.style.width = '100%';
        }

        // ... [SEMUA FUNGSI LAINNYA (setupCamera, renderLoop, runDetectionLoop, draw*, applyFilter*, etc.) TETAP SAMA SEPERTI VERSI SEBELUMNYA] ...
        // Inti dari optimasi ada di fungsi `createModels` di atas. Sisa dari logika operasional tidak perlu diubah.
        
        async function setupCamera() { /* ... */ const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480, facingMode: 'user' }, audio: false }); video.srcObject = stream; return new Promise(resolve => { video.onloadedmetadata = () => resolve(video); }); }
        function renderLoop() { canvas.width = video.videoWidth; canvas.height = video.videoHeight; ctx.save(); ctx.scale(-1, 1); ctx.translate(-canvas.width, 0); switch (currentFilter) { case 'thermal': case 'negative': const pHeight = Math.round(PROCESSING_CANVAS_WIDTH * (canvas.height / canvas.width)); processingCanvas.width = PROCESSING_CANVAS_WIDTH; processingCanvas.height = pHeight; processingCtx.drawImage(video, 0, 0, PROCESSING_CANVAS_WIDTH, pHeight); const imageData = processingCtx.getImageData(0, 0, PROCESSING_CANVAS_WIDTH, pHeight); if (currentFilter === 'thermal') applyThermalFilter(imageData); if (currentFilter === 'negative') applyNegativeFilter(imageData); processingCtx.putImageData(imageData, 0, 0); ctx.drawImage(processingCanvas, 0, 0, canvas.width, canvas.height); break; default: ctx.drawImage(video, 0, 0, canvas.width, canvas.height); break; } if (currentMode === 'object') drawObjectPredictions(lastObjectPredictions); if (currentFilter === 'teeth') drawTeethOverlay(lastFaceLandmarks); if (roiBox) { ctx.strokeStyle = 'yellow'; ctx.lineWidth = 4; ctx.strokeRect(roiBox.x, roiBox.y, roiBox.w, roiBox.h); } if (roiLine) { ctx.strokeStyle = 'yellow'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(roiLine.x1, roiLine.y1); ctx.lineTo(roiLine.x2, roiLine.y2); ctx.stroke(); } ctx.restore(); requestAnimationFrame(renderLoop); }
        let lastVideoTime = -1; async function runDetectionLoop() { if (video.readyState < 2 || video.paused) return; const videoTime = video.currentTime; if (videoTime === lastVideoTime) return; lastVideoTime = videoTime; if (objectModel && currentMode === 'object') { statusEl.textContent = 'Mendeteksi...'; statusEl.classList.add('status-pulse'); const predictions = await objectModel.detect(video); lastObjectPredictions = predictions; const personPrediction = predictions.find(p => p.class === 'person'); if (personPrediction) { pixelsPerCm = personPrediction.bbox[2] / 14.0; calibrationInfoEl.textContent = `Kalibrasi OK! 1cm â‰ˆ ${pixelsPerCm.toFixed(2)}px`; } } else { lastObjectPredictions = []; statusEl.classList.remove('status-pulse'); } if (faceLandmarker && currentFilter === 'teeth') { const result = faceLandmarker.detectForVideo(video, Date.now()); lastFaceLandmarks = result.faceLandmarks.length > 0 ? result.faceLandmarks[0] : null; } else { lastFaceLandmarks = null; } }
        function drawObjectPredictions(predictions) { predictions.forEach(p => { const [x, y, width, height] = p.bbox; const category = getCategory(p.class); ctx.strokeStyle = category.color; ctx.lineWidth = 4; ctx.strokeRect(x, y, width, height); ctx.fillStyle = category.color; const text = `${category.name} (${Math.round(p.score * 100)}%)`; ctx.font = '16px Inter, sans-serif'; const textWidth = ctx.measureText(text).width; ctx.fillRect(x, y, textWidth + 10, 25); ctx.fillStyle = '#ffffff'; ctx.fillText(text, x + 5, y + 18); if (pixelsPerCm) { const widthCm = (width / pixelsPerCm).toFixed(1); const heightCm = (height / pixelsPerCm).toFixed(1); const measurementText = `Est: ${widthCm}cm x ${heightCm}cm`; const measurementWidth = ctx.measureText(measurementText).width; ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(x, y + height - 20, measurementWidth + 10, 20); ctx.fillStyle = '#ffffff'; ctx.fillText(measurementText, x + 5, y + height - 5); } }); }
        const MOUTH_LANDMARKS_INDICES = [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291, 409, 270, 269, 267, 0, 37, 39, 40, 185, 61]; function drawTeethOverlay(landmarks) { if (!landmarks) return; ctx.fillStyle = 'rgba(255, 255, 0, 0.4)'; ctx.beginPath(); const firstPoint = landmarks[MOUTH_LANDMARKS_INDICES[0]]; ctx.moveTo(firstPoint.x * canvas.width, firstPoint.y * canvas.height); for (let i = 1; i < MOUTH_LANDMARKS_INDICES.length; i++) { const point = landmarks[MOUTH_LANDMARKS_INDICES[i]]; ctx.lineTo(point.x * canvas.width, point.y * canvas.height); } ctx.closePath(); ctx.fill(); }
        function applyNegativeFilter(imageData) { const data = imageData.data; for (let i = 0; i < data.length; i += 4) { data[i] = 255 - data[i]; data[i + 1] = 255 - data[i + 1]; data[i + 2] = 255 - data[i + 2]; } }
        function applyThermalFilter(imageData) { const data = imageData.data; for (let i = 0; i < data.length; i += 4) { const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3; const thermalColor = mapBrightnessToThermalColor(brightness); data[i] = thermalColor.r; data[i+1] = thermalColor.g; data[i+2] = thermalColor.b; } }
        function mapBrightnessToThermalColor(brightness) { const t = brightness / 255; let r=0, g=0, b=0; if (t < 0.25) { r = 0; g = t * 4 * 255; b = 255; } else if (t < 0.5) { r = (t - 0.25) * 4 * 255; g = 255; b = 255 - r; } else if (t < 0.75) { r = 255; g = 255 - (t - 0.5) * 4 * 255; b = 0; } else { r = 255; g = (t - 0.75) * 4 * 255; b = g; } return { r, g, b }; }
        filterRadios.forEach(radio => radio.addEventListener('change', (e) => { currentFilter = e.target.value; }));
        function switchMode(newMode) { currentMode = newMode; modeButtons.forEach(btn => { btn.classList.remove('btn-active'); if (btn.id === `mode-${newMode.replace('_', '-')}`) btn.classList.add('btn-active'); }); roiBox = null; roiLine = null; if (currentMode !== 'object') statusEl.textContent = 'Klik & seret untuk menggambar zona'; }
        modeButtons.forEach(btn => btn.addEventListener('click', () => switchMode(btn.id.replace('mode-', '').replace('-', '_'))));
        canvas.addEventListener('mousedown', (e) => { if (currentMode === 'object') return; isDrawing = true; startPoint = { x: canvas.width - e.offsetX, y: e.offsetY }; });
        canvas.addEventListener('mousemove', (e) => { if (!isDrawing) return; const endPoint = { x: canvas.width - e.offsetX, y: e.offsetY }; if (currentMode === 'roi-box') { roiBox = { x: Math.min(startPoint.x, endPoint.x), y: Math.min(startPoint.y, endPoint.y), w: Math.abs(startPoint.x - endPoint.x), h: Math.abs(startPoint.y - endPoint.y) }; } else if (currentMode === 'roi-line') { roiLine = { x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y }; } });
        canvas.addEventListener('mouseup', () => { if (!isDrawing) return; isDrawing = false; if (roiBox) statusEl.textContent = 'Zona Kotak Ditetapkan'; if (roiLine) { statusEl.textContent = 'Zona Garis Ditetapkan'; if (pixelsPerCm) { const dx = roiLine.x2 - roiLine.x1; const dy = roiLine.y2 - roiLine.y1; const distPixels = Math.sqrt(dx*dx + dy*dy); const distCm = (distPixels / pixelsPerCm).toFixed(1); statusEl.textContent = `Zona Garis: Estimasi ${distCm} cm`; } } });
        
        async function main() {
            await createModels();
            loaderText.innerText = 'Menyalakan kamera...';
            await setupCamera();
            loader.style.opacity = 0;
            setTimeout(() => loader.style.display = 'none', 500); // Sembunyikan setelah transisi selesai
            requestAnimationFrame(renderLoop);
            setInterval(runDetectionLoop, DETECTION_INTERVAL_MS);
        }
        main();
    </script>
</body>
</html>

